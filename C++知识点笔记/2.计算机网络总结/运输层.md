#### 传输层的作用

承上启下：实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等

传输层的功能:
1.传输层提供进程和进程之间的逻辑通信。网络层提供主机之间的逻辑通信。
2.复用和分用
3.传输层对收到的报文进行差错检测。
4.传输层的两种协议：UDP/TCP

### UDP协议

用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及查错检测的功能

#### 一、UDP的特点

1. UDP 是`无连接的`，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延

2. UDP 使用`尽最大努力交付`，即不保证可靠交付，主机不需要维持复杂的连接状态表

3. UDP 是`面向报文`的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是`保留这些报文的边界`

   <img src="C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\UDP面向报文.png" alt="UDP面向报文" style="zoom: 67%;" />

4. UDP `没有拥塞控制`，网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的

5. UDP 支持一对一、一对多、多对一和多对多的交互通信

6. UDP 的`首部开销小`，只有8个字节，比 TCP 的20个字节的首部要短

#### UDP缺点

1. 某些实时应用需要使用没有拥塞控制的 UDP，但很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，导致大家都无法正常接收。
2. 还有一些使用 UDP 的实时应用，需要对 UDP 的不可靠传输进行适当的改进，以减少数据的丢失。应用进程可以在不影响应用的实时性的前提下，增加一些提高可靠性的措施，如采用前向纠错或重传已丢失的报文

#### UDP格式

用户数据报 UDP 有两个字段：`数据字段`和`首部字段`。

首部字段很简单，只有8个字节，由四个字段组成，每个字段都是两个字节

![UDP报文](C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\UDP报文.png)

**端口分用**

当传输层从网络层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交最后的终点——应用进程，如果接受方 UDP 发现收到的报文中的目的端口号不正确(即不存在对应于该端口号的应用程序)，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方

<img src="C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\udp分用.png" alt="udp分用" style="zoom:80%;" />

**伪首部**

UDP 用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在 UDP 用户数据报之前增加 12 个字节的`伪首部`。所谓“伪首部”是因为这种伪首部并不是 UDP 用户数据报真正的首部。只是在计算检验和时，临时添加在 UDP 用户数据报前面，得到一个临时的 UDP 用户数据报。检验和就是按照这个临时用户数据报来计算的。伪首部既不向下传也不向上递交，而仅仅是为了计算检验和

**为什么需要伪首部**

目的是让 UDP 两次检查数据是否已经正确到达目的地。

一次，通过伪首部的IP地址检验，UDP可以确认该数据报是不是发送给本机IP地址的(即确认该数据包确实是传给该主机的）；第二，通过伪首部的协议字段检验，UDP可以确认IP有没有把不应该传给UDP而应该传给别的高层的数据报传给了UDP（即确认该数据确实是传给udp的）

所有伪首部包括：源 IP 地址，目的 IP 地址， 0，协议号， UDP 长度。

<img src="C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\UDP伪首部.png" alt="UDP伪首部" style="zoom:67%;" />

UDP校验

![UDP校验](C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\UDP校验.png)

### TCP/IP协议

#### 一、TCP协议的特点

TCP全称为 “传输控制协议”(Transmission Control Protocol)，顾名思义， 要对数据的传输进行一个详细的控制。有如下特点：
1、面向连接的
2、面向字节流
3、保证可靠传输(丢包重发,超时重传)
4、支持全双工通信
5、支持端口到端口的连接，每一条TCP连接只能有两个端点

#### 二、TCP协议段格式

![TCPIP报文](C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\TCPIP报文.png)

1、源/目的端口号: 表示数据是从哪个进程来, 到哪个进程去；

2、32位序号/32位确认号:

**序号seq：**在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一一个字节的序号。
**确认号ack:** 期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。
3、4位数据偏移(首部长度)  :TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即1个数值是4B，所以TCP头部最大长度是15 * 4 = 60
4、6位标志位:
**紧急位URG:** 紧急指针是否有效，为1表明报文中有紧急数据，应尽快传输，不用在缓存排队，结合紧急指针使用

**确认位ACK:** 确认号是否有效，ACK=1时 确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1

**推送位PSH:** PSH=1时， 接收方尽快交付接收应用进程，不再等到缓存填满再向上交付，提示接收端应用程序立刻从TCP缓冲区把数据读走

**复位RST:** RST=1时， 表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。

**同步位SYN:** SYN=1时， 表明是一一个连接请求/连接接受报文。

**终止位FIN:** FIN=1时， 表明此报文段发送方数据已发完，要求释放连接。
5、16位窗口大小: 现在允许对方发送的数据量，也就是自己现在的缓冲区多大

6、6位校验和: 发送端填充, CRC校验. 接收端校验不通过, 则认为数据有问题。检验首部+数据，检验时要加上12B伪首部，第四个字段为6。
7、16位紧急指针: 标识哪部分数据是紧急数据，URG=1时才有意义， 指出本报文段中紧急数据的字节数。

8、选项:最大报文段长度MSS、窗口扩大、时间戳、选择确认...

#### 三、TCP连接管理

**三次握手**

假设运行在一台主机(客户)上的一个进程想与另一台主机 (服务器)上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接:

![TCP三次握手](C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\TCP三次握手.png)

注：在round3中，若不携带数据，则不消耗序号，下次seq=x+1

（1）服务端状态转化:
[CLOSED->LISTEN]：服务器端调用listen后进入LISTEN状态, 等待客户端连接。

[LISTEN->SYN_RCVD]：一旦监听到连接请求(同步报文段)，就将该连接放入内核等待队列中, 并向客户端发送SYN确认报文(SYN=1,ACK=1,seq=y，ack=x+1)

[SYN_RCVD -> ESTABLISHED]：服务端一旦收到客户端的确认报文, 就进入ESTABLISHED状态, 可以进行读写数据了。

（2）客户端状态转化:
[CLOSED -> SYN_SENT]：客户端调用connect, 发送同步报文段(SYN=1,seq=x)

[SYN_SENT -> ESTABLISHED]：connect调用成功,发送确认(SYN=0,ACK=1,seq=x+1，ack=y+1)，则进入ESTABLISHED状态, 开始读写数据。

**四次挥手**

![TCP四次挥手](C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\TCP四次挥手.png)

（1）服务端状态转化:
[ESTABLISHED -> CLOSE_WAIT]：当客户端主动关闭连接(调用close), 服务器会收到结束报文段，服务器返回确认报文段(ACK=1,seq=v，ack=u+1)并进入CLOSE_WAIT；

[CLOSE_WAIT -> LAST_ACK]：进入CLOSE_WAIT后说明服务器准备关闭连接(需要处理完之前的数据); 当服务器真正调用close关闭连接时, 会向客户端发送FIN(FIN=1,ACK=1,seq=w,ack=u+1), 此时服务器进入LAST_ACK状态, 等待最后一个ACK到来(这个ACK是客户端确认收到了FIN) 

[LAST_ACK -> CLOSED]：服务器收到了对FIN的ACK, 彻底关闭连接。
（2）客户端状态转化:
[ESTABLISHED -> FIN_WAIT_1]： 客户端主动调用close时, 向服务器发送结束报文段(FIN=1,seq=u), 同时进入 FIN_WAIT_1;

[FIN_WAIT_1 -> FIN_WAIT_2]：客户端收到服务器对结束报文段的确认, 则进入FIN_WAIT_2, 开始等待服务器的结束报文段;

[FIN_WAIT_2 -> TIME_WAIT]：客户端收到服务器发来的结束报文段, 进入TIME_WAIT, 并发出 LAST_ACK(ACK=1,seq=u+1,ack=w+1);

[TIME_WAIT -> CLOSED]：客户端要等待一个2MSL的时间, 才会进入CLOSED状态 

**几个问题**

1.释放连接2MSL问题

MSL，指的是报文最大生存时间，也就是指报文从A端到B端单向的最大传输时间。

（1）保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失。
客户机发送完ACK报文段，经过2MSL时间后，本次连接持续时间内所产生的所有的报文段都从网络当中消失。这样就可以使得下一个新的连接中不会出现这种旧的连接请求报文段。

（2）保证四次挥手的时候客户机发送的最后一个ACK报文段能够到达服务器。
假设客户端LAST_ACK丢失了，此时服务器会再重发一个 FIN。(这时虽然客户端的进程不在了, 但是TCP连接还在, 仍然可以重发LAST_ACK)；然后客户机重传一次ACK确认报文段，重新启动时间2MSL等待定时器，这样才能确保客户机和服务器都进入CLOSED状态，防止因为客户机的ACK报文段的丢失导致服务器无法CLOSED。 

2.为什么要采用三次握手，二次握手可以吗?  

采用三次握手是为了防止已失效的请求报文段又传送到服务器，造成服务器崩溃。 （失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。）

若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。

假设网络拥塞，客户端发送的连接请求（第一次）迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。

3.为什么采用四次挥手（23合并起来ACK跟FIN一起发送）

确保数据能够完成传输，当关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的

#### 四、TCP可靠性

**1、校验和**  同UDP需要伪首部

**2、序列号(按序到达)** 

**3、确认应答（ACK）机制** TCP将每个字节的数据都进行了编号，即为序列号，每一个ACK都带有对应的确认序列号, 意思是告诉发送者, 我已经收到了哪些数据，下一次你从哪里开始发。 

**4、超时重传机制** 

传输数据时，可能会出现如下问题：
（1）主机A发送数据给B之后, 可能因为网络拥堵等原因, 数据无法到达主机B;
（2）主机A在一个特定时间间隔内没有收到B发来的确认应答, 会进行重发。（主机A未收到B发来的确认应答, 也可能是因为ACK丢失了）

解决方法：
这样的话，主机B就会收到很多重复数据，TCP协议需要能够识别出那些包是重复的包, 并且把重复的丢弃掉，可以利用前面提到的序列号, 很容易做到去重的效果。

超时的时间长短：动态改变重传时间RTTs （加权平均往返时间）
（1）Linux中(BSD Unix和Windows也是如此), 超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍.
（2）如果重发一次之后, 仍然得不到应答, 等待 2*500ms 后再进行重传.
（3）如果仍然得不到应答, 等待 4*500ms 进行重传. 依次类推, 以指数形式递增.
（4）累计到一定的重传次数, TCP认为网络或者对端主机出现异常, 强制关闭连接。 

#### 五、TCP流量控制

为什么需要流量控制

如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送, 就会造成丢包, 继而引起丢包重传等一系列连锁反应。
（1）当接受方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失
（2）通过窗口来控制 （窗口大小字段越大, 说明网络的吞吐量越高）
所以，简单来说，就是接收方处理不过来数据的时候，就把窗口缩小,并把窗口值告诉发送端。
TCP首部中, 有一个16位窗口字段, 就是存放了窗口的大小。接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd(接收方设置确认报文段的窗口字段来将rwnd通知给发送方) ，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。

<img src="C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\TCP流量控制.png" alt="TCP流量控制" style="zoom:80%;" />

#### 六、TCP拥塞控制

慢开始（慢启动）、拥塞避免、快速重传、快速恢复

cwnd设置为1，这里指的是一个报文段（其长度为一个最大报文段长度MSS），实际是字节，不考虑流量控制

**MTU = MSS + TCP Header + IP Header**

**慢开始：** TCP 开始发送设置 cwnd=1，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大，逐渐增加**拥塞窗口**的大小。

为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限（ ssthresh 状态变量）
当 cnwd＜ssthresh，使用慢开始算法
当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
当 cnwd＞ssthresh，使用拥塞避免算法

**拥塞避免：**在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞，并非完全能够避免拥塞。让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控
制窗口加一。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始算法。 如图所示：

![慢启动拥塞避免](C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\慢启动拥塞避免.png)

**快速重传：**

1. 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认（冗余ACK）就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
2. 由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。

**冗余ACK**
每当比期望序号大的失序报文段到达时，发送-一个冗余ACK，指明下-一个期待字节的序号。
发送方已发送1，2，3，4，5报文段
接收方收到1，返回给1的确认(确认号为2的第一个字节)
接收方收到3，仍返回给1的确认(确认号为2的第一一个字节)
接收方收到4，仍返回给1的确认(确认号为2的第一个字节)
接收方收到5，仍返回给1的确认(确认号为2的第一一个字节)
发送方收到3个对于报文段1的冗余ACK =认为2报 文段丢失，重传2号报文段快速重传

**快速恢复：** 

1. 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。但是接下去并不执行慢开始算法，执行拥塞避免算法。
2. 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。![快重传快启动](C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\快重传快启动.png)

**流量控制与拥塞控制的区别**

**流量控制**是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。 
**拥塞控制**是A与B之间的**网络**发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。