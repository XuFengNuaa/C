### 应用层作用

应用层对应用程序的通信提供服务。

应用层的功能:
文件传输、访问和管理 FTP
电子邮件 SMTP POP3
虚拟终端 HTTP
查询服务和远程作业登录 DNS

### DNS

DNS服务的作用:将域名解析成IP地址。

www.baidu.com 

www是三级域名、baidu是二级域名、com是顶级域名

<img src="C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\DNS.png" alt="DNS" style="zoom: 67%;" />

DNS工作过程

本地域名服务器:当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器。

工作分两种：递归查询、迭代递归相结合

![DNS服务过程](C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\DNS服务过程.png)

### HTTP

HTTP协议是应用层协议，是一个属于应用层的面向对象的协议

**HTTP协议的主要特点**

1、支持客户、服务器模式。
2、简单快速：客户面向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有：GET,HEAD,POST。
3、灵活：HTTP允许传输任意类型的数据对象，正在传输的类型需要加上Content-Type加以标记 。
4、无连接：无连接的含义是每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，及立即断开链接。采用这种方式可以节约很多时间。
5、无状态。HTTP协议是无状态协议，无状态是指协议对于事物处理没有记忆能力，缺少状态以为如果后序处理前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就较快。

**HTTP请求**
 四个部分：请求行,消息报头,空行,请求正文

<img src="C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\HTTP请求.png" alt="HTTP请求" style="zoom:67%;" />

**HTTP有很多请求方法，最常用的是GET方法和POST方法**

<img src="C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\请求方法.png" alt="请求方法" style="zoom:67%;" />

**POST、GET区别**

我们可以这样理解：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。

*GET* - 从指定的资源请求数据,把传送的数据放在url中，大多数浏览器url长度在2K个字节，大多数服务器能处理最长64K字节的url，只产生一个TCP包，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

*POST* - 向指定的资源提交要被处理的数据，把传送的数据放在body中，可以存放的数据多，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）但是不同浏览器不一定是产生两个TCP包

![POST_GET](C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\POST_GET.png)

**HTTP响应**

<img src="C:\Users\ZJH\Desktop\课件\计算机网络总结\图片\http响应.png" alt="http响应" style="zoom:67%;" />

HTTP有5种类型的**状态码**，具体的：

- 1xx：指示信息--表示请求已接收，继续处理。

- 2xx：成功--表示请求正常处理完毕。

- - 200 OK：客户端请求被正常处理。
  - 206 Partial content：客户端进行了范围请求。

- 3xx：重定向--要完成请求必须进行更进一步的操作。

- - 301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。
  - 302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。

- 4xx：客户端错误--请求有语法错误，服务器无法处理请求。

- - 400 Bad Request：请求报文存在语法错误。
  - 403 Forbidden：请求被服务器拒绝。
  - 404 Not Found：请求不存在，服务器上找不到请求的资源。

- 5xx：服务器端错误--服务器处理请求出错。

- - 500 Internal Server Error：服务器在执行请求时出现错误

### Cookie和session

#### 前言

HTTP是一种无状态的协议，为了分辨链接是谁发起的，就需要我们自己去解决这个问题。不然有些情况下即使是同一个网站我们每打开一个页面也都要登录一下。而Session和Cookie就是为解决这个问题而提出来的两个机制。

### 应用场景

日常登录一个网站，今天输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie。

session的一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息，这里就用到了session。

### Cookie

通俗讲，Cookie是访问某些网站以后在本地存储的一些网站相关的信息，下次再访问的时候减少一些步骤。另外一个更准确的[说法](http://www.lai18.com/content/407204.html)是：Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器，是一种在客户端保持状态的方案。

Cookie的主要内容包括：名字，值，过期时间，路径和域。使用Fiddler抓包就可以看见，比方说我们打开百度的某个网站可以看到Headers包括Cookie，如下：

Cookie的主要内容包括：名字，值，过期时间，路径和域。使用Fiddler抓包就可以看见，比方说我们打开百度的某个网站可以看到Headers包括Cookie，如下：

```
BIDUPSID: 9D2194F1CB8D1E56272947F6B0E5D47E
PSTM: 1472480791
BAIDUID: 3C64D3C3F1753134D13C33AFD2B38367:FG
ispeed_lsm: 2
MCITY: -131:
pgv_pvi: 3797581824
pgv_si: s9468756992
BDUSS: JhNXVoQmhPYTVENEdIUnQ5S05xcHZMMVY5QzFRNVh5SzZoV0xMVDR6RzV-bEJZSVFBQUFBJCQAAAAAAAAAAAEAAACteXsbYnRfY2hpbGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALlxKVi5cSlYZj
BD_HOME: 1
H_PS_PSSID: 1423_21080_17001_21454_21408_21530_21377_21525_21193_21340
BD_UPN: 123253
sug: 3
sugstore: 0
ORIGIN: 0
bdime: 0
```

可以看见是key,  value的形式，也就是我们说的对应着的名字，值。过期时间是可以设置的，如果不设置，则浏览器关掉就消失了，是存储在内存当中的，否则就是按照我们设置的时间来存储在硬盘上的，当过期后自动清除，比方说我们开机关机关闭再打开浏览器后他都会还存在，前者称之为Session cookie 又叫 transient cookie，后者称之为Persistent cookie 又叫 permenent  cookie。路径和域就是对应的域名，a网站的cookie自然不能给b用。

### Session

Session是存在服务器的一种用来存放用户数据的类HashTable结构。

> 当浏览器 第一次发送请求时，服务器自动生成了一个HashTable和一个Session  ID用来唯一标识这个HashTable，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session  ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session  ID进行对比，找到这个用户对应的HashTable。
>
> 摘自http://caibaojian.com/477.html

一般这个值会有一个时间限制，超时后毁掉这个值，默认是20分钟。

Session的实现方式和Cookie有一定关系。试想一下，建立一个连接就生成一个session  id，那么打开几个页面就好几个了，这显然不是我们想要的，那么该怎么区分呢？这里就用到了Cookie，我们可以把session  id存在Cookie中，然后每次访问的时候将Session id带过去就可以识别了，是不是很方便~

### 区别

1. Cookie是访问某些网站以后在本地存储的一些网站相关的信息，下次再访问的时候减少一些步骤；Session是存在服务器的一种用来存放用户数据的类HashTable结构
2. cookie保存在客户端session保存在服务端。因为Cookie存在客户端所以用户可以看见，所以也可以编辑伪造，不是十分安全。
3. Session过多的时候会消耗服务器资源，所以大型网站会有专门的Session服务器，而Cookie存在客户端所以没什么问题。
4. 域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而www.a.com的Session在api.a.com下都不能用，解决这个问题的办法是JSONP或者[跨域资源共享](http://www.ruanyifeng.com/blog/2016/04/cors.html)。

**HTTP无状态理解**

**无状态是指协议对于事务处理没有记忆功能**。每次的请求都是**独立的**，它的执行情况和结果与前面的请求和之后的请求是**无直接**关系的，它不会受前面的请求应答情况**直接**影响，也不会**直接**影响后面的请求应答情况

**实际中的使用情况：**

　　在web应用中，我们使用http协议，但是我们需要的web是有状态的，因此加入了cookie、session等机制实现有状态的的web。　**web=http协议+状态机制+其他机制**

cookies, session, application

A,给顾客发放一个磁卡，里面放有顾客过去的购买信息。

这样商店就可以知道了。这就是cookie.

B,给顾客发放一个唯一号码，号码制定的顾客的消费信息，存储在商店的服务器中。这就是session。

最后，商店可以全局的决定，是５瓶为送酒杯还是6瓶。这就是application。

**一次完整的 HTTP 请求所经历的步骤**

比如：在浏览器中输入 www.baidu.com 后执行的全部过程

`HTTP` 请求是依托于 `TCP` 连接的，第一次连接的时候会进行 `TCP` 的三次握手

从客户端的角度看数据发送

1. 客户端浏览器通DNS析到www. baidu. com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起个HTTP会话到220.161.27.48 ,然后通过TCP进行封装数据包,输入到网络层。
2. 客户端的传输层把HTTP会话请求分成报文段 添加源和目的端口，如服务器使用80端口监听客户
   端的请求,客户端由系统随机选择一 个端口如5000 ,与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。

3. 客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过点找路由表确定如何到达服务器，期间可能经过多个路由器,这些都是由路由器来完成的工作,=无非就是通过查找路由表决定通过那个路径到达服务器。
4. 客户端的链路层包通过链路层发送到路由器,通过邻居协议查找给定IP地址的MAC地址,然后发送
    ARP请求查找目的地址,如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了,然后发送IP数据包到达服务器的地址。

客户端与服务端的数据交互

1. 建立TCP连接：在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，首先要建立TCP连接，一般TCP连接的端口号是80。
2. 发送请求：一旦建立了TCP连接，客户端就会向Web服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。
3. Web浏览器发送请求头信息  浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送
4. Web服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。
5. Web服务器发送应答头信息：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。
6. Web服务器向浏览器发送数据 Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。
7. Web服务器关闭TCP连接 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

输入URL，首先浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。

得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理。如果采用https还会先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。

### HTTPS

HTTP的缺点：内容是**明文传输**的，没有经过任何加密，而这些明文数据会经过**WiFi、路由器、运营商、机房**等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，这一攻击手法叫MITM（Man In The Middle）**中间人**攻击。

**HTTPS实现原理**

HTTPS其实就是将HTTP的数据包再通过SSL/TLS加密后传输

HTTPS的加解密流程(非对称加密+对称加密)

1. 用户在浏览器发起HTTPS请求（如 https://www.mogu.com/），默认使用服务端的443端口进行连接；
2. HTTPS需要使用一套**CA数字证书**，证书内会附带一个**公钥Pub**，而与之对应的**私钥Private**保留在服务端不公开；
3. 服务端收到请求，返回配置好的包含**公钥Pub**的证书给客户端；
4. 客户端收到**证书**，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
5. 客户端生成一个用于对称加密的**随机Key**，并用证书内的**公钥Pub**进行加密，发送给服务端；
6. 服务端收到**随机Key**的密文，使用与**公钥Pub**配对的**私钥Private**进行解密，得到客户端真正想发送的**随机Key**；
7. 服务端使用客户端发送过来的**随机Key**对要传输的HTTP数据进行对称加密，将密文返回客户端；
8. 客户端使用**随机Key**对称解密密文，得到HTTP数据明文；
9. 后续HTTPS请求使用之前交换好的**随机Key**进行对称加解密。![https](C:\Users\ZJH\Desktop\课件\C++知识点笔记\2.计算机网络总结\图片\https.png)

**对称加密与非对称加密**

**对称加密**是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文。

如果通信双方都持有密钥，且天知地知你知我知，绝对不会有别的人知道，那么通信安全自然是可以得到保证的（在**密钥足够强**的情况下）在HTTPS的传输场景下，服务端事先并不知道客户端是谁，你也**不可能在事先不通过互联网和每一个网站的管理员都悄悄商量好一个通信密钥**出来

**非对称加密**有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开。

当客户端发起连接请求，服务端将公钥传输过去，客户端利用公钥加密好信息，再将密文发送给服务端，服务端里有私钥可以解密。但是，当服务端要返回数据，如果用公钥加密，那么客户端并没有私钥用来解密，而如果用私钥加密，客户端虽然有公钥可以解密，但这个公钥之前就在**互联网上传输过**，很有可能已经有人拿到，并不安全，所以这一过程只用非对称加密是不能满足的。

**非对称加解密耗时要远大于对称加解密**，我们才最终选用了上文介绍到非对称加密+对称加密的方案

1. 服务端有非对称加密的公钥A1，私钥A2；
2. 客户端发起请求，服务端将公钥A1返回给客户端；
3. 客户端随机生成一个对称加密的密钥K，用公钥A1加密后发送给服务端；
4. 服务端收到密文后用自己的私钥A2解密，得到对称密钥K，此时完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题
5. 之后双方通信都使用密钥K进行对称加解密

**CA颁发机构**

为了解决：**客户端无法确认收到的公钥是不是真的是服务端发来的**

服务端在使用HTTPS前，去经过认证的CA机构申请颁发一份**数字证书**，数字证书里包含有证书持有者、证书有效期、公钥等信息，服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。

私钥除了**解密**外的真正用途其实还有一个，就是**数字签名**，其实就是一种防伪技术，只要有人篡改了证书，那么数字签名必然校验失败。

1. CA机构拥有自己的一对公钥和私钥
2. CA机构在颁发证书时对证书明文信息进行哈希
3. 将哈希值用私钥进行**加签**，得到数字签名

**签名过程**

1. 明文数据和数字签名组成证书，传递给客户端。
2. 客户端得到证书，分解成明文部分Text和数字签名Sig1
3. 用CA机构的公钥进行**解签**，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）
4. 用证书里声明的哈希算法对明文Text部分进行哈希得到H
5. 当自己计算得到的哈希值H与**解签**后的Sig2**相等**，表示证书可信，**没有被篡改**

总结：

HTTPS 的出发点是解决HTTP明文传输时信息被篡改和监听的问题。

- 为了兼顾性能和安全性，使用了非对称加密+对称加密的方案。
- 为了保证公钥传输中不被篡改，又使用了非对称加密的数字签名功能，借助CA机构和系统根证书的机制保证了HTTPS证书的公信力。