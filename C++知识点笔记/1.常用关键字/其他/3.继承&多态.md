### 多态

1. 定义：“一个接口，多种方法”，程序在运行时才决定调用的函数。
2. 实现：C++多态性主要是通过虚函数实现的，虚函数允许子类重写override(注意和overload的区别，overload是重载，是允许同名函数的表现，这些函数参数列表/类型不同）。
3. 目的：**接口重用。**封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。
4. 用法：声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。向上转型 子类转父类 子类重写父类方法

多态是由虚函数实现的，而虚函数主要是通过**虚函数表（V-Table）**来实现的。

如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表，虚函数表存储的每一项是一个虚函数的地址。如下图：![虚函数虚表](C:\Users\ZJH\Desktop\课件\C++知识点笔记\1.常用关键字\pic\虚函数虚表.jpg)

这个类的每一个对象都会包含一个**虚指针**（虚指针存在于对象实例地址的最前面，保证虚函数表有最高的性能），这个虚指针指向虚函数表。

**注：对象不包含虚函数表，只有虚指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函数表。**

类的每一个对象有一个属于它自己的虚表指针，在构造函数初始化阶段，如果存在虚函数的话，虚表指针被初始化。如果存在构造函数的初始化列表的话，初始化列表也会被执行。

在gcc编译器的实现中虚函数表vtable存放在可执行文件的只读数据段.rodata中(全局数据或者静态数据)，是在编译期的

#### 对象模型

- 原始基类的虚函数表

下图是原始基类的对象，可以看到虚指针在地址的最前面，指向基类的虚函数表（假设基类定义了3个虚函数）<img src="C:\Users\ZJH\Desktop\课件\C++知识点笔记\1.常用关键字\pic\原始基类.png" alt="原始基类" style="zoom:67%;" />

- 单继承时的虚函数（**无重写基类虚函数**）

假设现在派生类继承基类，并且重新定义了3个虚函数，派生类会自己产生一个兼容基类虚函数表的**属于自己的虚函数表**。

<img src="C:\Users\ZJH\Desktop\课件\C++知识点笔记\1.常用关键字\pic\单继承无重写.png" alt="单继承无重写" style="zoom:67%;" />

　Derive class 继承了 Base class 中的三个虚函数，准确的说，是该函数实体的地址被拷贝到 Derive类的虚函数表，派生类新增的虚函数置于虚函数表的后面，并**按声明顺序存放**。

- 单继承时的虚函数（**重写基类虚函数**）

现在派生类重写基类的x函数，可以看到这个派生类构建自己的虚函数表的时候，修改了base::x()这一项，指向了自己的虚函数。

<img src="C:\Users\ZJH\Desktop\课件\C++知识点笔记\1.常用关键字\pic\单继承重写.png" alt="单继承重写" style="zoom:67%;" />

- 一般多重继承时的虚函数（Derived ::public Base1,public Base2）

这个派生类多重继承了两个基类base1，base2，因此它有两个虚函数表。

![多继承](C:\Users\ZJH\Desktop\课件\C++知识点笔记\1.常用关键字\pic\多继承.png)

* 菱形多重继承时的虚函数（class B1 : public B，class B2 : public B ，class D : public B1, public B2）

菱形继承也称为钻石型继承或重复继承，它指的是基类被某个派生类简单重复继承了多次。这样，派生类对象中拥有多份基类实例（这会带来一些问题）。

<img src="C:\Users\ZJH\Desktop\课件\C++知识点笔记\1.常用关键字\pic\菱形继承问题.png" alt="菱形继承问题" style="zoom:50%;" />

由于D类间接继承了B类两次，导致D类对象中含有两个B类的数据成员ib，一个属于来源B1类，一个来源B2类。这样不仅增大了空间，更重要的是引起了程序歧义

```cpp
D d;
d.ib =1 ;               //二义性错误,调用的是B1的ib还是B2的ib？
```

* 简单虚继承

在C++对象模型中，虚继承而来的子类会生成一个隐藏的虚基类指针（vbptr），在Microsoft Visual C++中，**虚基类表指针总是在虚函数表指针之后**，

一个类的**虚基类指针**指向的**虚基类表**，与虚函数表一样，虚基类表也由多个条目组成，条目中存放的是**偏移值**。**第一个条目**存放虚基类表指针（vbptr）所在地址到该类内存首地址的偏移值；虚基类表的**第二**、第三...个条目依次为该类的最左**虚继承父类**、次左虚继承父类...的内存地址相对于虚基类表指针的偏移值，这点我们在下面会验证。

```cpp
class B{...}
class B1 : virtual public B
```

<img src="C:\Users\ZJH\Desktop\课件\C++知识点笔记\1.常用关键字\pic\简单虚继承.png" alt="简单虚继承" style="zoom:50%;" />

* 菱形虚继承

```cpp
class B{...}
class B1: virtual public  B{...}
class B2: virtual public  B{...}
class D : public B1,public B2{...}
```

菱形虚拟继承下，最派生类D类的对象模型又有不同的构成了。在D类对象的内存构成上，有以下几点：

* 在D类对象内存中，基类出现的顺序是：先是B1（最左父类），然后是B2（次左父类），最后是B（虚祖父类）

* D类对象的数据成员id放在B类前面，两部分数据依旧以0来分隔。

* 编译器没有为D类生成一个它自己的vptr，而是覆盖并扩展了最左父类的虚基类表，与简单继承的对象模型相同。

* 超类B的内容放到了D类对象内存布局的最后。

<img src="C:\Users\ZJH\Desktop\课件\C++知识点笔记\1.常用关键字\pic\菱形虚继承.png" alt="菱形虚继承" style="zoom:50%;" />

**纯虚函数：**

- 定义： 在很多情况下，基类本身生成对象是不合情理的。为了解决这个问题，方便使用类的多态性，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= **0**;）纯虚函数不能再在基类中实现，编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。
- 特点：

1. 当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；（避免类被实例化且在编译时候被发现，可以采用此方法）
2. 这个方法必须在派生类(derived class)中被实现；

- 目的：使派生类仅仅只是继承函数的接口。

**抽象类：**

- 定义：称至少带有一个纯虚函数的类为抽象类。

- 作用：为一个继承体系提供一个公共的根，为派生类提供操作接口的通用语义。

- 特点：
  1. 抽象类只能作为基类来使用，而继承了抽象类的派生类如果没有实现纯虚函数，而只是继承纯虚函数，那么该类仍旧是一个抽象类，如果实现了纯虚函数，就不再是抽象类。
  2. 抽象类不可以定义对象。

**多重继承**

定义：派生类继承多个基类，派生类为每个基类（显式或隐式地）指定了访问级别——`public`、`protected` 或 `private`。

```cpp
    class Panda : public Bear, public Endangered {
    }
```

构造：

1. 派生类的对象包含每个基类的基类子对象。
2. 派生类构造函数初始化所有基类（多重继承中若没有显式调用某个基类的构造函数，则编译器会调用该基类默认构造函数），派生类只能初始化自己的基类，并不需要考虑基类的基类怎么初始化。
3. 多重继承时，基类构造函数按照基类构造函数在类派生列表中的出现次序调用。

析构：总是按构造函数运行的**逆序**调用析构函数。（基类的析构函数最好写成virtual，否则再父类对象销毁的时候，无法销毁子类对象部分资源。）假定所有根基类都将它们的析构函数适当定义为虚函数，那么，无论通过哪种指针类型删除对象，虚析构函数的处理都是一致的。

拷贝构造/赋值：

​		如果要为派生类编写拷贝构造函数，则需要为调用基类相应拷贝构造函数并为其传递参数，否则只会拷贝派生类部分。

**虚继承与虚基类：**

定义：在多重继承下，一个基类可以在派生层次中出现多次。（派生类对象中可能出现多个基类对象）在 C++ 中，通过使用**虚继承**解决这类问题。虚继承是一种机制，类通过虚继承指出它希望共享其虚基类的状态。在虚继承下，对给定虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象。共享的基类子对象称为**虚基类**。

用法：`istream` 和 `ostream` 类对它们的基类进行虚继承。通过使基类成为虚基类，`istream` 和 `ostream` 指定，如果其他类（如 `iostream` 同时继承它们两个，则派生类中只出现它们的公共基类ios的一个副本。通过在派生列表中包含关键字 `virtual` 设置虚基类：

```cpp
class istream : public virtual ios { ... };
class ostream : virtual public ios { ... };
    // iostream inherits only one copy of its ios base class
class iostream: public istream, public ostream { ... };
```