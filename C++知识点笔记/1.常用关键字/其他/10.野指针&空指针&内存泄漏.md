### 空指针
 没有存储任何内存地址的指针就称为空指针(NULL指针)
 空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。
 给空指针发消息是没有任何反应的。

```c++
Student *s1 = NULL;
//空指针异常：指用NULL指针来调用类中的方法，可以通过判NULL来避免
```

### 野指针

野指针(wild pointer)就是没有被初始化过的指针。

```c++
int main(){
	int *p;
	return (*p & 0x7f);
}
```

### 悬空指针

指针正常初始化，曾指向过一个正常的对象，但是对象销毁了，该指针未置空，就成了悬空指针。

```c++
int main() {
    int *p; // 指针未初始化，此时 p 为野指针 
    int *pi = nullptr;

    {
        int i = 6;
        pi = &i; // 此时 pi 指向一个正常的地址
        *pi = 8; // ok
    }   

    *pi = 6; // 由于 pi 指向的变量 i 已经销毁，此时 pi 即成了悬空指针

    return 0;
}
```

### 危害

无论是野指针还是悬空指针，都是**指向无效内存区域(这里的无效指的是"不安全不可控")的指针**。 访问"不安全可控"(invalid)的内存区域将导致"Undefined Behavior"。

也就是说：任何可能都会发生。要么编译失败，要么执行得不正确(崩溃(e.g. segmentation fault)或者悄无声息地产生不正确的执行结果)，或者偶尔会正确地产生程序员希望运行的结果。

1. 避免使用野指针的办法

 养成在定义指针后且在使用之前完成**初始化**的习惯就好。

2. 避免使用悬空指针

智能指针(smart pointer)。**智能指针的本质是使用引用计数（reference counting）来延迟对指针的释放。**

### 内存泄露
 栈区的指向已经释放,  堆区的空间没有释放, 这时堆区的空间就被泄露了（堆区,需要程序员手动管理），new出来的东西没用delete掉，这部分空间在无法访问了，

### 内存溢出

内存越界有一种很常见的情况是调用栈溢出（即stackoverflow），虽然这种情况可以看成是栈内存不足的一种体现。但内存溢出并不一定跟内存分配有什么关系，因为还有一种情况是缓冲区溢出。

溢出指用户实际的数据长度超过了申请的内存空间大小，导致覆盖了其他正常数据，容易造成程序异常

### 重复释放两次

未知错误，可能是coredump，段错误通常发生在访问非法内存地址的时候，即使用了野指针（指向一个已删除的对象或者未申请访问受限内存区域的指针）或这试图修改字符串常量的内容。