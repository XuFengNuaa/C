## 指针和引用

从本质上来说，指针是一个**变量**，引用是**别名**

1. 从现象上看：指针在运行时可以改变所指向的值，而引用一旦与某个对象绑定后就不再改变。意思是：指针可以被重新赋值以指向另一个对象，但是引用则总是在初始化时被指定的对象，以后不能改变，但是指向的内容可以改变。
2. 内存分配：程序为指针变量分配区域，而不为引用分配内存区域。因为引用声明时必须初始化，从而指向一个已经存在的对象，引用不能为空值。
3. 编译：程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。**指针变量**在符号表上对应的地址值为指针变量的地址值，而**引用**在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说引用可以被认为是不能改变的指针。

| 引用         | 指针         |
| ------------ | ------------ |
| 必须初始化   | 可以不初始化 |
| 不能为空     | 可以为空     |
| 不能更换目标 | 可以更换目标 |

1. 引用必须初始化，而指针可以不初始化。

```c++
int &r;    //不合法，没有初始化引用
int *p;    //合法，但p为野指针，使用需要小心
```

2. 引用不能为空，而指针可以为空。

由于引用不能为空，所以我们在使用引用的时候不需要测试其合法性，而在使用指针的时候需要首先判断指针是否为空指针，否则可能会引起程序崩溃。

```c++
void test_p(int* p)
{
    if(p != null_ptr)    //对p所指对象赋值时需先判断p是否为空指针
        *p = 3;
    return;
}
void test_r(int& r)
{
    r = 3;    //由于引用不能为空，所以此处无需判断r的有效性就可以对r直接赋值
    return;
}
```

3. 引用不能更换目标

指针可以随时改变指向，但是引用只能指向初始化时指向的对象，无法改变。

```c++
int a = 1;
int b = 2;

int &r = a;    //初始化引用r指向变量a
int *p = &a;   //初始化指针p指向变量a

p = &b;        //指针p指向了变量b
r = b;         //引用r依然指向a，但a的值变成了b
```

指针跟引用性能

C++中引入了引用操作，在对引用的使用加了更多限制条件的情况下，保证了引用使用的安全性和便捷性，还可以保持代码的优雅性。在适合的情况使用适合的操作，引用的使用可以一定程度避免“指针满天飞”的情况，对于提升程序稳定性也有一定的积极意义。最后，指针与引用底层实现都是一样的，不用担心两者的性能差距。



指针：

```c++
void test(int *p){
    p = (int*) malloc(10);
    cout<<p<<endl;//p的地址
}

int* c =NULL;
test(c);
cout<<c<<endl;//0
```

p这部分的内存泄漏