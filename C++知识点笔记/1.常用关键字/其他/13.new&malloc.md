1. new分配内存按照数据类型进行分配，malloc分配内存按照大小分配；
2. new不仅分配一段内存，而且会调用构造函数，但是malloc则不会。new的实现原理？但是还需要注意的是，之前看到过一个题说int* p = new int与int* p = new int()的区别，因为int属于C++内置对象，不会默认初始化，必须显示调用默认构造函数，但是对于自定义对象都会默认调用构造函数初始化。翻阅资料后，在C++11中两者没有区别了，自己测试的结构也都是为0；
3. new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化；
   new是一个操作符可以重载，malloc是一个库函数；
4. new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会；
5. malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作；
6. new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。因此对于new，正确的姿势是采用try…catch语法，而malloc则应该判断指针的返回值。为了兼容很多c程序员的习惯，C++也可以采用new nothrow的方法禁止抛出异常而返回NULL；
7. new和new[]的区别，new[]一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]，同理，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n；
8. 如果不够可以继续谈new和malloc的实现，空闲链表，分配方法(首次适配原则，最佳适配原则，最差适配原则，快速适配原则)。delete和free的实现原理，free为什么知道销毁多大的空间？

**realloc** 将已经存在的一块内存扩大

```c++
char* p = malloc(1024);
char* q = realloc(p,2048)
```

  1**.**如果 当前连续内存块足够 realloc 的话，只是将p所指向的空间扩大，并返回p的指针地址。 这个时候 q 和 p 指向的地址是一样的**。**

​    2.如果 当前连续内存块不够长度，再找一个足够长的地方，分配一块新的内存，q，并将 p指向的内容 copy到 q，返回 q**。**并将p所指向的内存空间删除。

 这样也就是说 realloc 有时候会产生一个新的内存地址 有的时候不会**。**所以在分配完成后。我们需要判断下 p 是否等于 q。并做相应的处理。



1、new

new操作针对数据类型的处理，分为两种情况：

（1） 简单数据类型（包括基本数据类型和不需要构造函数的类型）

- 简单类型直接调用operator new分配内存；
- 可以通过new_handler来处理new失败的情况；
- new分配失败的时候不像malloc那样返回NULL，它直接抛出异常。要判断是否分配成功应该用异常捕获的机制；

（2）复杂数据类型（需要由构造函数初始化对象）

　　 new 复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数。

2、delete 

delete也分为两种情况：

（1） 简单数据类型（包括基本数据类型和不需要析构函数的类型）

　　 delete简单数据类型默认只是调用free函数。

（2）复杂数据类型（需要由析构函数销毁对象）

　　 delete复杂数据类型先调用析构函数再调用operator delete。

3、new 数组

new[]也分为两种情况：

（1） 简单数据类型（包括基本数据类型和不需要析构函数的类型）

　　针对简单类型，new[]计算好大小后调用operator new。

（2）复杂数据类型（需要由析构函数销毁对象）

　　针对复杂类型，new[]会额外存储数组大小。

4、delete 数组

delete[]也分为两种情况：

（1） 简单数据类型（包括基本数据类型和不需要析构函数的类型）

　　针对简单类型，delete和delete[]等同。

（2）复杂数据类型（需要由析构函数销毁对象）

　　针对复杂类型，new[]出来的内存只能由delete[]释放。

**malloc**

1）当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)

2）当开辟的空间大于 128K 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。

malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。 

调用  malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。  

将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）  接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。

 调用 free  函数时，它将用户释放的内存块连接到空闲链表上。

 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，  那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。



malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：

- First fit：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块
- Best fit：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块

　　两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。

