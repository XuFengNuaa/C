## 分页存储管理

### 基本概念

将**内存空间**分为一个个大小相等的分区（ 比如： 每个分区4KB） ， 每个分区就是一个“ 页框” （ 页框=页帧=内存块=物理块=物理页面） 。 每个页框有一个编号， 即“页框号” （ 页框号=页帧号=内存块号=物理块号=物理页号） ， 页框号从0开始。

将**进程的逻辑地址空间**也分为与页框大小相等的一个个部分，每个部分称为一个**“页” 或“ 页面”** 。 每个页面也有一个编号，即**“页号”** ， 页号也是从0开始

操作系统以**页框**为单位为各个进程分配内存空间。 进程的每个页面分别放入一个页框中。 也就是说， 进程的页面与内存的页框有一一对应的关系。

各个页面不必连续存放， 可以放到不相邻的各个页框中

页表：整个进程分成的页以后，记录页号 + 对应的内存块号，记录进程页面和实际存放的内存块之间的映射关系

页表项：页表中的一项，页号+块号

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\页表.png" alt="页表" style="zoom: 67%;" />

**问题1：**每个页表项占多少字节

假设某系统物理内存大小为 4GB， 页面大小为 4KB

内存块大小=页面大小=4KB= 2^12B

4GB 的内存总共会被分为 2^32 / 2^12 = 2^20个内存块

**内存块号**的范围应该是 0 ~2^20 -1 -->内存块号至少要用 20 bit 来表示 ，至少要用3B（24bit）来表示块号

**页号**可以是隐含的，不占存储空间，因为页表项连续存放

**问题2：**将进程地址空间分页之后， 操作系统该如何实现逻辑地址到物理地址的转换

逻辑地址A 对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W

确定一个逻辑地址对应的页号、 页内偏移量

假设某计算机用32 个二进制位表示逻辑地址， 页面大小为 4KB= 2^12B = 4096B

```
逻辑地址 2， 用二进制表示应该是 00000000000000000000 000000000010

页号 = 2/4096 = 0 = 00000000000000000000， 页内偏移量 = 2%4096 = 2 = 000000000010
```

```
逻辑地址 4097， 用二进制表示应该是 00000000000000000001 000000000001
页号 = 4097/4096 = 1 = 00000000000000000001， 页内偏移量 = 4097%4096 = 1 = 000000000001
```

```
假设通过查询页表得知1号页面存放的内存块号是9（ 1001） ， 则
9号内存块的起始地址 = 9*4096 = 00000000000000001001000000000000
则逻辑地址4097对应的物理地址 = 页面在内存中存放的起始地址 + 页内偏移量
=（ 00000000000000000011000000000001）
```

分页存储管理的逻辑地址结构如下所示：

![逻辑地址结构](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\逻辑地址结构.png)

地址长度为 32 位， 其中 0~11位 为“ 页内偏移量” ， 或称“页内地址” ； 12~31 位为“ 页号”

如果有 K 位表示  ， 则说明该系统中一个页面的大小是 2^K个内存单元
如果有 M 位表示“页号” ， 则说明在该系统中， 一个进程最多允许有 2^M 个页面

### 基本地址变换机构

基本地址变换机构可以**借助进程的页表**将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\基本执行机构.png" alt="基本执行机构" style="zoom:67%;" />

①算页号、页内偏移量
②检查页号合法性
③查页表，找到页面存放的内存块号
④根据内存块号与页内偏移量得到物理地址
⑤访问目标内存单元

### 具有快表的地址变换机构

快表， 又称联想寄存器（TLB，translation	lookaside	buffer） ， 是一种访问速度比内存快很多的高速缓存（TLB不是内存） ， 用来存放最近访问的页表项的副本， 可以加速地址变换的速度。与此对应， 内存中的页表常称为慢表。<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\快表.png" alt="快表" style="zoom:67%;" />

①算页号、页内偏移量
②检查页号合法性
③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④
④查页表，找到页面存放的内存块号，并且将页表项复制到快表中
⑤根据内存块号与页内偏移量得到物理地址
⑥访问目标内存单元

由于查询快表的速度比查询页表的速度快很多， 因此只要快表命中， 就可以节省很多时间。
因为**局部性原理**， 一般来说快表的命中率可以达到 90% 以上。

**局部性原理**

时间局部性： 如果执行了程序中的某条指令， 那么不久后这条指令很有可能再次执行； 如果某个数据被访问过， 不久之后该数据很可能再次被访问。 （ 因为程序中存在大量的循环）
空间局部性： 一旦程序访问了某个存储单元， 在不久之后， 其附近的存储单元也很有可能被访问。 （ 因为很多数据在内存中都是连续存放的）

### 两级页表

**页表结构**

把页表分页

![两级页表](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\两级页表.png)

**如何地址变换**

![两级页表访问](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\两级页表访问.png)

若分为两级页表后， 页表依然很长， 则可以采用更多级页表， 一般来说各级页表的大小不能超过一个页面

### 分段存储

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\分段存储.png" alt="分段存储" style="zoom:67%;" />

分段系统的逻辑地址结构由段号（ 段名） 和段内地址（ 段内偏移量） 所组成。

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\分段逻辑地址.png" alt="分段逻辑地址" style="zoom:67%;" />

```
段号的位数决定了每个进程最多可以分几个段
段内地址位数决定了每个段的最大长度是多少
在上述例子中， 若系统是按字节寻址的， 则
段号占16位， 因此在该系统中， 每个进程最多有 2^16 = 64K 个段
段内地址占 16位， 因此每个段的最大长度是 2^16 = 64KB。
```

**地址变换**

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\分段寻址.png" alt="分段寻址" style="zoom:67%;" />

**分段与分页对比**

1. **页**是信息的物理单位。 分页的主要目的是为了实现离散分配， 提高内存利用率。 分页仅仅是系统管
   理上的需要， 完全是系统行为， 对用户是不可见的。
   **段**是信息的逻辑单位。 分段的主要目的是更好地满足用户需求。 一个段通常包含着一组属于一个逻
   辑模块的信息。 分段对用户是可见的， 用户编程时需要显式地给出段名。
2. **页的大小**固定且由系统决定。 **段的长度**却不固定， 决定于用户编写的程序
3. 分页的用户进程地址空间是**一维**的， 程序员只需给出一个记忆符即可表示一个地址。
   分段的用户进程地址空间是**二维**的， 程序员在标识一个地址时， 既要给出段名， 也要给出段内地址。
4. 分段比分页更容易实现信息的**共享和保护**。 不能被修改的代码称为纯代码或可重入代码（ 不属于临
   界资源） ， 这样的代码是可以共享的。 可修改的代码是不能共享的

**访问一个逻辑地址需要几次访存？**
分页（ 单级页表） ： 第一次访存——查内存中的页表， 第二次访存——访问目标内存单元。 总共两次
访存
分段： 第一次访存——查内存中的段表， 第二次访存——访问目标内存单元。 总共两次访存
与分页系统类似， 分段系统中也可以引入快表机构， 将近期访问过的段表项放到快表中， 这样可以
少一次访问， 加快地址变换速度。

### 段页式管理

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\段页.png" alt="段页" style="zoom:67%;" />

将进程按逻辑模块分段，再将各段分页(如每个页面4KB )再将内存空间分为大小相同的内存块/页框/页帧/物理块进程前将各页面分别装入各内存块中

**段页式逻辑地址结构**

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\段页地址结构.png" alt="段页地址结构" style="zoom:67%;" />

段号的位数决定了每个进程最多可以分几个段
页号位数决定了每个段最大有多少页.
页内偏移量决定了页面大小、内存块大小是多少

**段表、页表**

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\段表页表.png" alt="段表页表" style="zoom:67%;" />

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\20190606090541487.png" alt="20190606090541487" style="zoom: 67%;" />

### 虚拟内存技术

把程序中的一部分放入到内存中，对程序员透明。可以根据内存的使用情况，动态的对程序部分内容在内存与外存中进行交换。

可以解决的问题：

1. 一次性： 作业必须一次性全部装入内存后才能开始运行。 这会造成两个问题： ①作业很大时， 不能全部装入内存， 导致大作业无法运行； ②当大量作业要求运行时， 由于内存无法容纳所有作业， 因此只有少量作业能运行， 导致多道程序并发度下降。
2. 驻留性： 一旦作业被装入内存， 就会一直驻留在内存中， 直至作业运行结束。 事实上， 在一个时间段内， 只需要访问作业的一小部分数据即可正常运行， 这就导致了内存中会驻留大量的、 暂时用不到的数据， 浪费了宝贵的内存资源。

提供的功能：**缓存**，**内存管理**，**内存保护**

1. 将主存视为一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据
2. 为每个进程提供了一致的地址空间，简化内存管理，操作系统为每个进程提供一个独立的`页表`，因而也就是独立的虚拟地址空间。
   * 简化链接：每个进程的虚拟内存空间都是一致而且固定的，所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际的内存地址
   * 简化加载：把目标文件（可执行文件和共享对象文件）中的.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，加载器不从磁盘复制任何数据到内存中，虚拟内存系统会按需自动调入数据页
   * 简化共享：当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，将不同进程中适当的虚拟页面映射到相同的物理页面，节省内存
   * 简化内存分配：在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。
3. 保护了每个进程的地址空间不被其他进程破坏

根据的是**局部性原理**，参考上面快表

**虚拟页式内存管理技术=页式内存管理+请求调页+页面置换功能。**

**基本思路**：
1.当一个用户程序要调入内存运行时，不是将该程序的所有页面都装入内存，而是只装入部分的页面，就可以启动程序。
2.在运行的过程中，如果发现要运行的程序或要访问的数据不再内存，则向系统发出缺页中断请求，系统在处理这个中断请求时，将外存中响应的页面调入内存，是程序能够继续运行。

**请求分页管理：**

页表新增四个字段：**页表=内存块号+状态位+访问位+修改位+外存地址**

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\请求分页.png" alt="请求分页" style="zoom: 67%;" />

**工作流程：**

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\虚拟工作流程.png" alt="虚拟工作流程" style="zoom: 50%;" />

**缺页中断机构**

1. 在请求分页系统中， 每当要访问的页面不在内存时， 便产生一个缺页中断， 然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞， 放入阻塞队列， 调页完成后再将其唤醒， 放回就绪队列。
2. 如果内存中有空闲块， 则为进程分配一个空闲块， 将所缺页面装入该块， 并修改页表中相应的页表项。
3. 如果内存中没有空闲块， 则由页面置换算法选择一个页面淘汰， 若该页面在内存期间被修改过， 则要将其写回外存。 未修改过的页面不用写回外存

### 页面置换算法

- 最优页面置换算法（OPT）
- 先进先出算法（FIFO）
- 最近最久未使用（LRU）
- 时钟页面置换算法（Clock）
- 最不常用算法（LFU）

**1. 最优页面置换算法（OPT）**

思路：把将来最长时间不需要的页面置换。
最佳置换算法可以保证最低的缺页率， 但实际上， 只有在进程执行的过程中才能知道接下来会访问到
的是哪个页面。 操作系统无法提前预判页面访问序列。 因此， 最佳置换算法是**无法实现**的。

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\最优页面置换.png" alt="最优页面置换" style="zoom: 67%;" />

**2.先进先出算法（FIFO）**

思路：每次选择淘汰的页面是最早进入内存的页面
实现方法： 把调入内存的页面根据调入的先后顺序排成一个队列， 需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。
性能较差，调出的页面可能是经常要访问的页面，并且有Belady现象（当为进程分配的物理块数增大时， 缺页次数不减反增的异常现象。）。FIFO很少单独使。

Belady原因：算法置换特征与程序访问内存的动态特征是矛盾的，所以置换出去的页面不一定是进程会访问的。

**3.最近最久未使用（LRU）**

思路：每次淘汰的页面是最近最久未使用的页面
实现方法： 赋予每个页面对应的页表项中， 用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时， 选择现有页面中 t 值最大的， 即最近最久未使用的页面。

**4.时钟页面置换算法（Clock）**

思路：利用页表中的访问位（Access Bit），初始化为0，每次访问后都会置为1，操作系统又定期将其变为0。

当发生缺页中断时，若当前访问位==1则置0，指针向下走，直到遇到访问位==0的页面就进行置换；

若当前访问位==0则置换该页，然后指针指向下一个地址。在这个过程中，指针类似于时钟往一个方向走。

**5.最不常用法（LFU）**

思路：当缺页中断发生时，将访问次数最少的那个页面置换。

缺点：一个页面在一开始频繁访问，后续就不访问了。会导致内存利用率不高。

**LRU，FIFO，Clock总结**

- LRU和FIFO本质上都是**先进先出**的思路，但LRU是针对页面**最近访问时间**来排序，每次对内存的访问都要排序而FIFO不需要。
- 当内存中所有的页面**都没被访问过**时，LRU就退化为FIFO。
- LRU**算法性能好，但系统开销较大**；FIFO**系统开销小，但可能会发生Belady**。而Clock算法就是他们的折衷，每次页面访问时不用调整页面在链表的顺序，而是用寄存器中原生的标记，等发生**缺页中断时再维护链表**。Clock性能和LRU差不多，但对于曾经访问过的页面不能记住他们准确的位置。

### 页面分配策略

驻留集： 指请求分页存储管理中给进程分配的物理块的集合。

固定分配： 操作系统为每个进程分配一组固定数目的物理块， 在进程运行期间不再改变。 即，驻留集大小不变
可变分配： 先为每个进程分配一定数目的物理块， 在进程运行期间， 可根据情况做适当的增加或减少。即， 驻留集大小可变

局部置换： 发生缺页时只能选进程自己的物理块进行置换。
全局置换： 可以将操作系统保留的空闲物理块分配给缺页进程， 也可以将别的进程持有的物理块置换
到外存， 再分配给缺页进程。

**固定分配局部置换：** 系统为每个进程分配一定数量的物理块， 在整个运行期间都不改变。 若进程在运行中发生缺页， 则只能从该进程在内存中的页面中选出一页换出， 然后再调入需要的页面。 这种策略的缺点是： 很难在刚开始就确定应为每个进程分配多少个物理块才算合理。 （ 采用这种策略的系统可以根据进程大小、 优先级、 或是根据程序员给出的参数来确定为一个进程分配的内存块数）

**可变分配全局置换：** 刚开始会为每个进程分配一定数量的物理块。 操作系统会保持一个空闲物理块队列。 当某进程发生缺页时， 从空闲物理块中取出一块分配给该进程； 若已无空闲物理块， 则可选择一个未锁定的页面换出外存， 再将该物理块分配给缺页的进程。 采用这种策略时， 只要某进程发生缺页，都将获得新的物理块， 仅当空闲物理块用完时， 系统才选择一个未锁定的页面调出。 被选择调出的页可能是系统中任何一个进程中的页， 因此这个被选中的进程拥有的物理块会减少， 缺页率会增加。

**可变分配局部置换：** 刚开始会为每个进程分配一定数量的物理块。 当某进程发生缺页时， 只允许从该进程自己的物理块中选出一个进行换出外存。 如果进程在运行中频繁地缺页， 系统会为该进程多分配几个物理块， 直至该进程缺页率趋势适当程度； 反之， 如果进程在运行中缺页率特别低， 则可适当减少分配给该进程的物理块。

**小结：**

可变分配全局置换： 只要缺页就给分配新物理块
可变分配局部置换： 要根据发生缺页的频率来动态地增加或减少进程的物理块

**何时何处调入页面：**

预调页策略： 主要用于进程的首次调入，由程序员指出应该先调入哪些部分

请求调页策略： 进程在运行期间发现缺页时才将所缺页面调入内存。 由这种策略调入的页面一定会被访问到， 但由于每次只能调入一页， 而每次调页都要磁盘I/O操作， 因此I/O开销较大。

UNIX 方式： 运行之前进程有关的数据全部放在文件区， 故未使用过的页面， 都可从文件区调入。 若被使用过的页面需要换出， 则写回对换区， 下次需要时从对换区调入。

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\调入页面.png" alt="调入页面" style="zoom:67%;" />

**抖动颠簸现象：**

刚刚换出的页面马上又要换入内存， 刚刚换入的页面马上又要换出外存， 这种频繁的页面调度行为称
为抖动， 或颠簸。 产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（ 分配给进程
的物理块不够）

驻留集： 指请求分页存储管理中给进程分配的内存块的集合。
**工作集：** 指在某段时间间隔里， 进程实际访问页面的集合。

操作系统会根据“窗口尺寸” 来算出工作集。 例：
某进程的页面访问序列如下， 窗口尺寸为 4， 各时刻的工作集为？

工作集大小可能小于窗口尺寸， 实际应用中， 操作系统可以统计进程的工作集大小， 根据工作集大小给进程分配若干内存块。 如： 窗口尺寸为5， 经过一段时间的监测发现某进程的工作集最大为3， 那么说明该进程有很好的局部性， 可以给这个进程分配3个以上的内存块即可满足进程的运行需要。一般来说， 驻留集大小不能小于工作集大小， 否则进程运行过程中将频繁缺页。

基于局部性原理可知， 进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。
因此， 可以根据进程近期访问的页面集合（ 工作集） 来设计一种页面置换算法——选择一个不在工作
集中的页面进行淘汰

