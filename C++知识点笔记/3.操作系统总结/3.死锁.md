## 死锁

### 产生条件

1. **互斥：**只有对必须互斥使用的资源的争抢才会导致死锁。

2. **不可剥夺条件：**进程所获得的资源在未使用完之前， 不能由其他进程强行夺走， 只能主动释放。

3. **请求和保持条件：** 进程已经保持了至少一个资源， 但又提出了新的资源请求， 而该资源又被其他进程占有， 此时请求进程被阻塞， 但又对自己已有的资源保持不放。

4. **循环等待条件：** 存在一种进程资源的循环等待链， 链中的每一个进程已获得的资源同时被下一个进程所请求。

### 处理方法

主要有以下四种方法：

- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

### 死锁预防

![3NELNUBG}AO`6E@Z53E[]1L](C:\Users\ZJH\Documents\Tencent Files\1972106872\FileRecv\MobileFile\Image\3NELNUBG}AO`6E@Z53E[]1L.png)

### 死锁避免

安全序列：如果系统按照这种序列分配资源， 则每个进程都能顺利完成。 只要能找出一个安全序列， 系统就是安全状态。 当然， 安全序列可能有多个。
如果分配了资源之后， 系统中找不出任何一个安全序列， 系统就进入了不安全状态。 这就意味着之后可能所有进程都无法顺利的执行下去。 当然， 如果有进程提前归还了一些资源， 那系统也有可能重新回到安全状态， 不过我们在分配资源之前总是要考虑到最坏的情况。
如果系统处于安全状态， 就一定不会发生死锁。 如果系统进入不安全状态， 就可能发生死锁（ 处于不
安全状态未必就是发生了死锁， 但发生死锁时一定是在不安全状态）

**银行家算法：**

核心思想： 在进程提出资源申请时， 先预判此次分配是否会导致系统进入不安全状态。 如果会进
入不安全状态， 就暂时不答应这次请求， 让该进程先阻塞等待。

```c++
数据结构：
长度为 m 的一维数组 Available 表示还有多少可用资源
n*m 矩阵 Max 表示各进程对资源的最大需求数
n*m 矩阵 Allocation 表示已经给各进程分配了多少资源
Max – Allocation = Need 矩阵表示各进程最多还需要多少资源
用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数
```

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\银行家数据结构.png" alt="银行家数据结构" style="zoom:67%;" />

银行家算法步骤：
①检查此次申请是否超过了之前声明的最大需求数
②检查此时系统剩余的可用资源是否还能满足这次请求
③试探着分配， 更改各数据结构
④用安全性算法检查此次分配是否会导致系统进入不安全状态

安全性算法步骤：
检查当前的剩余可用资源是否能满足某个进程的最大需求， 如果可以， 就把该进程加入安全序列，
并把该进程持有的资源全部回收。
不断重复上述过程， 看最终是否能让所有进程都加入安全序列。

### 死锁检测与死锁恢复

①死锁检测算法： 用于检测系统状态， 以确定系统中是否发生了死锁。
②死锁解除算法： 当认定系统中已经发生了死锁， 利用该算法可将系统从死锁状态中解脱出来。

1.每种类型一个资源的死锁检测

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\死锁检测1.png" alt="死锁检测1" style="zoom:67%;" />

上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。

图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。

每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

2.每种类型多个资源的死锁检测

![死锁检测2](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\死锁检测2.png)

上图中，有三个进程四个资源，每个数据代表的含义如下：

- E 向量：资源总量
- A 向量：资源剩余量
- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R 矩阵：每个进程请求的资源数量

进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。

算法总结如下：

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。
2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。
3. 如果没有这样一个进程，算法终止。

解除死锁的主要方法有：

1. 资源剥夺法。 挂起（ 暂时放到外存上） 某些死锁进程， 并抢占它的资源， 将这些资源分配给
   其他的死锁进程。 但是应防止被挂起的进程长时间得不到资源而饥饿。
2. 撤销进程法（ 或称终止进程法） 。 强制撤销部分、 甚至全部死锁进程， 并剥夺这些进程的资
   源。 这种方式的优点是实现简单， 但所付出的代价可能会很大。 因为有些进程可能已经运行
   了很长时间， 已经接近结束了， 一旦被终止可谓功亏一篑， 以后还得从头再来。
3.  进程回退法。 让一个或多个死锁进程回退到足以避免死锁的地步。 这就要求系统要记录进程
   的历史信息， 设置还原点。