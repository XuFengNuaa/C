## 进程管理

### 进程与线程

**1.进程**

进程是资源分配的基本单位。

进程组成：PCB（进程描述信息、控制管理信息、资源分配信息等）、程序段（程序中代码）、数据段（运行过程中产生的各种数据）

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\PCB.png" alt="PCB" style="zoom: 67%;" />

下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\a6ac2b08-3861-4e85-baa8-382287bfee9f.png" alt="a6ac2b08-3861-4e85-baa8-382287bfee9f" style="zoom:67%;" />

进程的特征：

1. **动态**（pcb进程控制块是进程存在的唯一的标志）：进程是程序的一次执行，它有着创建，活动，暂停，终止等过程，具有一定的生命周期（由pcb决定），是动态的产生，变化和消亡的。动态性是进程最基本的征。

2. **并发性**：指多个进程实体，同存在于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征。**引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。**

3. **独立性**：指进程实体是一个能独立运行，独立获得资源和独立接受调度的基本单位。凡是为建立pcb的程序都不能作为一个独立的单位参与运行。

4. **异步性**：由于进程的相互制约，使进程具有执行的间断性，即进程按照各自的独立的，不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制。

5. **结构性**：每个进程都配置一个pcb对其进行描述。从结构上看，进程实体是由程序段，数据段和进程控制段三部分组成。

进程的组织形式：

链接方式：按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针

索引方式：按照进程状态的不同，建立几张索引表，操作系统持有各个索引表的指针

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\链接方式.png" alt="链接方式" style="zoom:50%;" />

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\索引方式.png" alt="索引方式" style="zoom:50%;" />

**2.线程**

线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\3cd630ea-017c-488d-ad1d-732b4efeddf5.png" alt="3cd630ea-017c-488d-ad1d-732b4efeddf5" style="zoom:67%;" />

**3.进程线程的区别**

Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

进程所维护的是程序所包含的资源（静态资源）， 如：**地址空间，打开的文件句柄集，文件系统状态，信号处理handler等**；

线程所维护的运行相关的资源（动态资源），如：**运行栈，调度相关的控制信息，待处理的信号集等**；

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU  环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

**协程**，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）

**上下文切换**

- 进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。
- 线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。
- 协程的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。

### 进程状态切换

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\ProcessState.png" alt="ProcessState" style="zoom:67%;" />

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

进程控制会导致进程状态的转换，无论哪个进程控制原语， 要做的无非三类事情：

1. 更新PCB中的信息
   a. 所有的进程控制原语一定都会修改进程状态标志
   b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
   c. 某进程开始运行前必然要恢复期运行环境
2.  将PCB插入合适的队列
3. 分配/回收资源

### 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

调度算法的评价：<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\调度算法评价.png" alt="调度算法评价" style="zoom:75%;" />

#### 批处理操作系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

**1.先来先服务 first-come first-serverd（FCFS）**  

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\先来先服务.png" alt="先来先服务" style="zoom:67%;" />

**2. 短作业优先 shortest job first（SJF）**  

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\短作业有先.png" alt="短作业有先" style="zoom:67%;" />

**3.最短剩余时间优先 shortest remaining time next（SRTN）**  

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

#### 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

**1. 时间片轮转**  

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

**2.优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**3. 多级反馈队列**  

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

<img src="C:\Users\ZJH\Desktop\课件\操作系统总结\pic\042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="042cf928-3c8e-4815-ae9c-f2780202c68f" style="zoom:67%;" />

#### 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

### 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 进程同步

**1.临界区**

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```html
// entry section
// critical section;
// exit section
```

**2.同步与互斥**

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

**3.信号量**

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- P  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；申请资源
- V  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 P操作。释放资源

**P和 V**操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了   **互斥量（Mutex）**  ，0 表示临界区已经加锁，1 表示临界区解锁。

**4.管程**

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了   **条件变量**   以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

### 经典同步问题

用信号量实现进程同步：（前V后P）

1. 分析什么地方需要实现“同步关系” ， 即必须保证“ 一前一后” 执行的两个操作（ 或两句代码）
2. 设置同步信号量 S, 初始为 0
3. 在“ 前操作” 之后执行 V(S)
4. 在“ 后操作” 之前执行 P(S)

信号量S代表“某种资源” ， 刚开始是没有这种资源的。 P2需要使用这种资源，而又只能由P1产生这种资源

```
P1(){
	code1;
	code2;
	V(S);
	code3;
}
P2(){
	P(S);
	code4;
	code5;
	code6;
}
```

若先执行到 V(S) 操作， 则 S++ 后 S=1。 之后当执行到 P(S) 操作时， 由于 S=1， 表示有可用资源， 会执行 S--， S 的值变回 0，P2 进程不会执行 block 原语， 而是继续往下执行代码4。

若先执行到 P(S) 操作， 由于 S=0， S-- 后 S=-1， 表示此时没有可用资源， 因此P操作中会执行 block 原语， 主动请求阻塞。之后当执行完代码2， 继而执行 V(S) 操作， S++， 使 S 变回 0，由于此时有进程在该信号量对应的阻塞队列中， 因此会在 V操作中执行 wakeup 原语， 唤醒 P2 进程。 这样 P2 就可以继续执行 代码4 了

**1.消费者-生产者**

有一组生产者进程和一组消费者进程， 生产者进程每次生产一个产品放入缓冲区， 消费者进程每次从缓冲区中取出一个产品并使用。 （ 注： 这里的“ 产品” 理解为某种数据）

生产者、 消费者共享一个初始为空、 大小为n的缓冲区。

只有缓冲区没满时， 生产者才能把产品放入缓冲区， 否则必须等待。

只有缓冲区不空时， 消费者才能从中取出产品， 否则必须等待。

缓冲区是临界资源， 各进程必须互斥地访问

**思路：**

1. 因为缓冲区属于临界资源，因此需要使用一个 mutex 来控制对缓冲区的互斥访问。

2. 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0  时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

```c++
semaphore mutex = 1; //互斥信号量，实现对缓冲区的互斥访问
semaphore empty = n; //同步信号量，表示空闲缓冲区的数量
semaphore full = 0; //同步信号量，表示产品的数量，也即非空缓冲区的数量
```

![生产消费者](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\生产消费者.png)

**注意：**实现互斥的P操作一定要在实现同步的P操作之后，V操作不会导致进程阻塞， 因此两个V操作顺序可以交换

**2.多生产者-多消费者**

桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。 只有盘子空时， 爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。

分析：互斥关系：缓冲区盘子要互斥反问（mutex=1）

同步关系（一前一后）：

1. 父亲将苹果放入盘子后， 女儿才能取苹果
2. 母亲将橘子放入盘子后， 儿子才能取橘子
3. 只有盘子为空时， 父亲或母亲才能放入水果

```c++
semaphore mutex = 1; //实现互斥访问盘子（缓冲区）
semaphore apple = 0; //盘子中有几个苹果
semaphore orange = 0; //盘子中有几个橘子
semaphore plate = 1; //盘子中还可以放多少个水果
```

![多生产者](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\多生产者.png)

**3.吸烟者问题**

假设一个系统有三个抽烟者进程和一个供应者进程。 每个抽烟者不停地卷烟并抽掉它， 但是要卷起并抽掉一支烟， 抽烟者需要有三种材料： 烟草、 纸和胶水。 三个抽烟者中， 第一个拥有烟草、第二个拥有纸、 第三个拥有胶水。 供应者进程无限地提供三种材料， 供应者每次将两种材料放桌子上， 拥有剩下那种材料的抽烟者卷一根烟并抽掉它， 并给供应者进程一个信号告诉完成了， 供应者就会放另外两种材料再桌上， 这个过程一直重复（ 让三个抽烟者轮流地抽烟）

![吸烟者](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\吸烟者.png)

吸烟者问题可以为我们解决“可以生产多个产品的单生产者” 问题提供供一个思路。
值得吸取的精华是： “轮流让各个吸烟者吸烟” 必然需要“ 轮流的在桌上放上组合一、 二、 三” ， 注意体会我们是如何用一个整型变量 i 实现这个“ 轮流” 过程的。

**4.读者写者问题**

有读者和写者两组并发进程， 共享一个文件， 当两个或两个以上的读进程同时访问共享数据时不会产生副作用， 但若某个写进程和其他进程（ 读进程或写进程） 同时访问共享数据时则可能导致数据不一致的错误。 因此要求： ①允许多个读者可以同时对文件执行读操作； ②只允许一个写者往文件中写信息； ③任一写者在完成写操作之前不允许其他读者或写者工作； ④写者执行写操作前， 应让已有的读者和写者全部退出。

两类进程： 写进程、 读进程
互斥关系： 写进程—写进程、 写进程—读进程。 读进程与读进程不存在互斥问题。

读优先：存在写饥饿问题

![读优先](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\读优先.png)

相对公平：

![公平读写](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\公平读写.png)

**5.哲学家进餐问题**

一张圆桌上坐着5名哲学家， 每两个哲学家之间的桌上摆一根筷子， 桌子的中间是一碗米饭。 哲学家们倾注毕生的精力用于思考和进餐， 哲学家在思考时， 并不影响他人。 只有当哲学家饥饿时，才试图拿起左、 右两根筷子（ 一根一根地拿起） 。 如果筷子已在他人手上， 则需等待。 饥饿的哲学家只有同时拿起两根筷子才可以开始进餐， 当进餐完毕后， 放下筷子继续思考。![哲学家问题](C:\Users\ZJH\Desktop\课件\操作系统总结\pic\哲学家问题.png)

```
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex = 1; //互斥地取筷子
Pi (){ //i号哲学家的进程
	while(1){
        P(mutex);
        P(chopstick[i]); //拿左
        P(chopstick[(i+1)%5]); //拿右
        V(mutex);
        吃饭…
        V(chopstick[i]); //放左
        V(chopstick[(i+1)%5]); //放右
        思考…
	}
}
```

情况1：假设0拿起了左筷子，进程切换到2,2发生阻塞，当0拿起右筷子并解锁，然后2号才拿左右两个筷子

情况2：0号拿起了左右筷子，开始吃饭，发生进程切换到1号，则一号阻塞在拿左筷子操作上，发生进程切换到2号， 即使2号左右两边的筷子都在， 也暂时无法取得

情况3：0号拿起了左右筷子，开始吃饭，4拿起了左边的筷子，右边的筷子没有（正在被0使用），发生阻塞在拿右筷子，4号右边的筷子不可用， 但4号仍然会先拿起左边的筷子

各哲学家拿筷子这件事必须互斥的执行。 这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞， 也不会有别的哲学家会继续尝试拿筷子。 这样的话，当前正在吃饭的哲学家放下筷子后， 被阻塞的哲学家就可以获得等待的筷子了